# 자료구조 정리

## 1. 배열 (Array)
같은 타입 원소들이 연속해서 저장되어있는 자료구조

- 장점
  1. 원하는 원소 참조가 빠름 ( O(1) )

- 단점
  1. 미리 크기를 정해야하고, 변경할 수 없음
  2. 삽입과 삭제가 cost가 큼 ( O(N) )


## 2. 연결 리스트 (Linked List)
1. 단일 링크드 리스트
  - 노드 : <원소, 주소> 형태의 단위 구조
  - 단일 링크드 리스트 : 노드들이 링크 필드에 의해 다음 노드와 연결되는 자료구조

    - 장점 : 정해져있지 않은 크기
    - 단점 : 원하는 원소 참조를 위해 순차적으로 접근해야함 ( O(N) )

2. 이중 링크드 리스트
  - 이전 노드를 가리키는 포인터도 존재 -> 양방향 탐색 가능

3. 환형 링크드 리스트
  - 단일 링크드 리스트의 tail과 head가 연결되어있는 형태
  - cursor라는 노드를 통해 탐색 시작 지점을 알수 있다.




## 3. 스택 (Stack)
- top에서만 자료의 삽입, 삭제가 이루어지는 자료구조
- 후입선출(LIFO, Last-In First-Out) 구조

- 삽입, 삭제 : O(1)

- 응용
  1. 중위 표기법 - 연산자를 피연산자 가운데 표기하는 방법 ex) A+B
  2. 후위 표기법 - 연산자를 피연산자 뒤에 표기하는 방법 -> 연산자 우선순위 고려 없이 왼쪽에서 오른쪽으로 처리 가능 ex) AB+



## 4. 큐 (Queue)
- 원소가 rear에서 삽입되고, front를 통해 삭제되는 자료구조
- 선입선출(First-In Last-Out) 구조

1. 배열기반 선형 큐
  - 삽입과 삭제를 반복하면 배열의 크기를 넘어갈 수 없어 front 이전의 공간이 남아도 사용 불가능

2. 배열기반 원형 큐
  - 삽입 삭제를 반복해도 front 이전의 공간을 사용 -> 메모리 효율 but 비어있거나 꽉차면 rear와 front가 겹쳐 구분 불가능 -> 한칸을 비워서 사용

3. 양방향 큐 (데크, Deque)
  - front, read 양쪽에서 삽입, 삭제 가능한 자료구조




## 5. 트리
: 부모 - 자식 관계로 이루어진 노드의 집합

특징
1. 루트 노드 : 부모를 갖지 않는 최상위 노드, 루트 노드를 제외한 노드들은 단 하나의 부모 노드를 가짐

구성
Siblings : 부모가 같은 노드 (형제 노드)
Leaf : 자식 노드가 없는 노드
Subtree : 부모 노드와의 연결을 끊고 자신을 루트로 삼았을 때 생성되는 트리

노드의 크기(size) : 자신을 포함한 모든 자손 노드의 개수
노드의 차수(degree) : 한 노드의 자식의 수
노드의 레벨(level) : 특정 깊이를 가지는 노드의 집합
노드의 깊이(depth) : 루트에서 자신까지 가는 경로의 길이 ex) root 노드의 depth는 0
노드의 높이(height) : 자신과 자손 중 단말 노드 사이의 경로의 최대 길이 ex) leaf 노드의 height는 0
트리의 깊이 혹은 높이는 모든 것들 중 최댓값으로 정의

트리 순회
1. 전위 순회 (preorder) : 루트 -> 자식들
2. 후위 순회 (postorder) : 자식들 -> 루트




## 6. 우선순위 큐 (Priority Queue)
: 들어간 순서에 상관 없이 우선순위에 따라 front가 달라지는 자료구조

구현
1. 정렬되지 않은 시퀀스 : 삽입 - O(1), 삭제 - O(n)
2. 정렬된 시퀀스 : 삽입 - O(N), 삭제 - O(1)
3. 힙 (Heap)

힙 (Heap) 조건
1. 완전 이진 트리 : 항상 왼쪽부터 채워져야 함
2. heap-order를 만족해야함 ex) 최소 우선순위 큐 : key(v) >= key(parent(v))

힙 구현 : 배열을 이용해서 쉽게 가능
0번 인덱스를 비워 1부터 시작하면 parent가 i 일때 왼쪽 자식은 2 * i 이고, 오른쪽 자식은 2 * i + 1 이다.

시간 복잡도 : 삽입 - O(log n), 삭제 - O(log n)

힙 생성 방법
1. on line 방식 : 데이터가 입력될 때마다 조건 확인 : O(n * log n)
2. off line 방식 : 일단 배열에 전부 입력받고, 조건 확인 : O(n)





## 7. 이진 탐색 트리 (Binary Search Tree)
이진 탐색 : 정렬된 배열에서 사용할 수 있는 탐색 알고리즘
1. 중앙값 선택
2. 중앙값과 목표 값 비교
3. 목표 값이 중앙값보다 작으면 왼쪽에서, 크면 오른쪽에서 검색
1~3을 값을 찾을 때까지 반복

이진 탐색 트리 : 각 내부노드 v가 key(v.left) <= key(v) <= key(v.right)를 만족하는 자료구조

시간 복잡도
균형 트리 : O(log n)
불균형 트리 : O(n)


이진 탐색 트리 연산
1. 삽입 연산 - 탐색 수행 후 실패한 위치에 새 노드 삽입
2. 삭제 연산 : 세가지 경우 존재(1. 삭제 노드가 리프 노드, 2. 삭제 노드가 왼쪽 혹은 오른쪽 서브트리 하나만 가지고 있는 경우, 3. 삭제 노드가 두개의 서브 트리 가지고 있는 경우)




## 8. 해싱 (Hashing)
해싱 - 키 값에 대한 산술 연산을 통해 테이블의 주소를 계산하여 항목에 접근하는것
해시 테이블 - 키 값의 연산에 의해 접근 가능한 자료구조

해시 함수 - 탐색 키(k)를 입력받아 임의 정수에 매핑하는 함수
ex) h(x) = x mod N

충돌 (Collision)
- 서로 다른 탐색키 k1, k2에 대해 h(k1) = h(k2)인 경우

제산 함수 (Division Function)
- h(k) = k mod M (M은 소수 선택)

충돌 해결 방법
1. 선형조사법, 이중해싱법 : 충돌이 일어난 항목을 다른 위치에 저장
2. 체이닝 : 각 셀에 연결 리스트 할당


선형 조사법 (Linear Probing)
1. hashTable[i] 에서 충돌이 발생했을 때 hashTable[i + 1] 비어있는지 조사
2. 빈 공간 나올 때까지 계속 조사, 테이블 끝에 가면 다시 처음부터 조사


이중 해싱법 (Double Hashing)
- 충돌 발생 시 추가적인 해시 함수 사용
- i = h(k) = k mod M, d(k) = N - (k mod N)
- i<j> = (i + j * d(k)) mod M


탐색 방법들의 시간 복잡도
			탐색		삽입		삭제
순차 탐색			O(n)		O(1)		O(n)
이진 탐색			O(log n)		O(log n + n)	O(log n + n)
이진 탐색 트리(균형)	O(log n)		O(log n)		O(log n)
이진 탐색 트리(경사)	O(n)		O(n)		O(n)
해싱(최선)		O(1)		O(1)		O(1)
해싱(최악)		O(n)		O(n)		O(n)








## 9. 그래프 (Graph)
- 정점(Vertex)과 간선(Edge)으로 이루어진 자료구조

그래프와 트리의 차이
	그래프			트리
노드들을 연결하는 간선들의 집합	사이클이 없는 연결 그래프
사이클 가능			사이클 존재 불가능
두 정점 사이 여러 경로 가능		두 정점 사이 반드시 1개 경로
간선 수 다양			간선 수 = 정점 수 - 1

트리는 그래프의 한 종류이다.







