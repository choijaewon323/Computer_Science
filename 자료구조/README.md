# 자료구조 정리
					
## 1. 배열 (Array)
- 같은 타입 원소들이 연속해서 저장되어있는 자료구조

#### 장점
- 원하는 원소 참조가 빠름 ( O(1) )

#### 단점
- 미리 크기를 정해야하고, 변경할 수 없음
- 삽입과 삭제가 cost가 큼 ( O(N) )

					
## 2. 연결 리스트 (Linked List)
#### 1. 단일 링크드 리스트
- 노드 : <원소, 주소> 형태의 단위 구조
- 단일 링크드 리스트 : 노드들이 링크 필드에 의해 다음 노드와 연결되는 자료구조
    - 장점 : 정해져있지 않은 크기
    - 단점 : 원하는 원소 참조를 위해 순차적으로 접근해야함 ( O(N) )

#### 2. 이중 링크드 리스트
  - 이전 노드를 가리키는 포인터도 존재 -> 양방향 탐색 가능

#### 3. 환형 링크드 리스트
  - 단일 링크드 리스트의 tail과 head가 연결되어있는 형태
  - cursor라는 노드를 통해 탐색 시작 지점을 알수 있다.


				

## 3. 스택 (Stack)
- top에서만 자료의 삽입, 삭제가 이루어지는 자료구조
- 후입선출(LIFO, Last-In First-Out) 구조
- 삽입, 삭제 : O(1)

#### 응용
  1. 중위 표기법 - 연산자를 피연산자 가운데 표기하는 방법 ex) A+B
  2. 후위 표기법 - 연산자를 피연산자 뒤에 표기하는 방법 -> 연산자 우선순위 고려 없이 왼쪽에서 오른쪽으로 처리 가능 ex) AB+
				


## 4. 큐 (Queue)
- 원소가 rear에서 삽입되고, front를 통해 삭제되는 자료구조
- 선입선출(First-In Last-Out) 구조

#### 1. 배열기반 선형 큐
  - 삽입과 삭제를 반복하면 배열의 크기를 넘어갈 수 없어 front 이전의 공간이 남아도 사용 불가능

#### 2. 배열기반 원형 큐
  - 삽입 삭제를 반복해도 front 이전의 공간을 사용 -> 메모리 효율 but 비어있거나 꽉차면 rear와 front가 겹쳐 구분 불가능 -> 한칸을 비워서 사용

#### 3. 양방향 큐 (데크, Deque)
  - front, read 양쪽에서 삽입, 삭제 가능한 자료구조

			
			

## 5. 트리 (Tree)
- 부모 - 자식 관계로 이루어진 노드의 집합

#### 특징
- 루트 노드 : 부모를 갖지 않는 최상위 노드, 루트 노드를 제외한 노드들은 단 하나의 부모 노드를 가짐

#### 구성
- Siblings : 부모가 같은 노드 (형제 노드)
- Leaf : 자식 노드가 없는 노드
- Subtree : 부모 노드와의 연결을 끊고 자신을 루트로 삼았을 때 생성되는 트리	

- 노드의 크기(size) : 자신을 포함한 모든 자손 노드의 개수
- 노드의 차수(degree) : 한 노드의 자식의 수
- 노드의 레벨(level) : 특정 깊이를 가지는 노드의 집합
- 노드의 깊이(depth) : 루트에서 자신까지 가는 경로의 길이 ex) root 노드의 depth는 0
- 노드의 높이(height) : 자신과 자손 중 단말 노드 사이의 경로의 최대 길이 ex) leaf 노드의 height는 0
- 트리의 깊이 혹은 높이는 모든 것들 중 최댓값으로 정의

#### 트리 순회
1. 전위 순회 (preorder) : 루트 -> 자식들
2. 후위 순회 (postorder) : 자식들 -> 루트

				


## 6. 우선순위 큐 (Priority Queue)
- 키에 대한 우선순위를 통해 데이터 저장
- 삽입에 대해서는 임의의 원소 모두 가능하지만, 삭제는 우선순위에 맞춰 수행됨

### 우선순위 큐 구현
- 정렬 안된 리스트로 구현
	- 삽입 : O(1)
	- 삭제 : 모든 리스트 요소 탐색해야함 -> O(n)
- 정렬된 리스트로 구현
	- 삽입 : 모든 리스트 요소 탐색 필요 -> O(n)
	- 삭제 : O(1)

### 힙
- 이진 트리
- 특성
	- 힙 오더 특성 : minHeap의 경우 부모가 자식보다 키 값이 작거나 같아야함
	- 완전 이진 트리 특성 : 완전 이진 트리여야함
- 완전 이진 트리의 벡터 표현
	- 루트인 경우 인덱스 1
	- v가 u의 왼쪽 자식 : v 인덱스 = u * 2
	- v가 u의 오른쪽 자식 : v 인덱스 = u * 2 + 1

### 힙을 사용한 우선순위 큐 구현
- 삽입
	- 이진 트리 삽입을 통해 삽입할 위치 찾음 -> 완전 이진 트리 특성 만족
	- 이 상태로는 힙 오더 특성 불만족
	- 부모와 새로운 노드를 비교하여 힙 오더 만족할 때까지 스왑 - upheap
- 삭제
	- 루트를 제거하고 맨 마지막 노드를 루트로 이동
	- 이 상태로는 힙 오더 불만족
	- 만약 자식이 왼쪽 자식밖에 없으면 -> 그냥 스왑
	- 둘다 있으면 -> 둘중에 작은걸로 스왑
	- 이 과정을 힙 오더 만족할때까지 반복 - downheap
- 삽입, 삭제 모두 O(log n) 시간에 가능


### 힙 생성 방법
1. on line 방식 : 데이터가 입력될 때마다 조건 확인 : O(n * log n)
2. off line 방식 : 일단 배열에 전부 입력받고, 조건 확인 : O(n)



			

## 7. 이진 탐색 트리 (Binary Search Tree)
#### 이진 탐색 : 정렬된 배열에서 사용할 수 있는 탐색 알고리즘
1. 중앙값 선택
2. 중앙값과 목표 값 비교
3. 목표 값이 중앙값보다 작으면 왼쪽에서, 크면 오른쪽에서 검색
4. 1~3을 값을 찾을 때까지 반복

#### 이진 탐색 트리 : 각 내부노드 v가 key(v.left) <= key(v) <= key(v.right)를 만족하는 자료구조

#### 시간 복잡도
- 균형 트리 : O(log n)
- 불균형 트리 : O(n)


#### 이진 탐색 트리 연산
1. 삽입 연산 - 탐색 수행 후 실패한 위치에 새 노드 삽입
2. 삭제 연산 : 세가지 경우 존재(1. 삭제 노드가 리프 노드, 2. 삭제 노드가 왼쪽 혹은 오른쪽 서브트리 하나만 가지고 있는 경우, 3. 삭제 노드가 두개의 서브 트리 가지고 있는 경우)


						

## 8. 해시 테이블 (Hash Table)

### 컴포넌트
- 버켓 배열, 해시 함수

### 버켓 배열
- 배열의 각 셀이 버켓(통)

### 해시 함수
- 키를 특정 범위로 매핑시켜주는 함수
- 해시의 결과로 나온 값 h(k)를 버켓 배열의 인덱스로 사용
- 엔트리 (k, v) 를 A[h(k)] 에 저장
- 다른 키가 같은 해시 값을 갖는것 - 충돌
- 해시 함수의 두가지 액션
	- 해시 코드 : 임의의 자료형인 키 k를 정수로 매핑
	- 압축 함수 : 해시 코드를 특정 범위 안의 정수로 압축

### 충돌 해결 방법
- Separate Chaining (분리 체이닝) : 배열의 각 셀이 리스트로 - 추가 공간 필요
- Open Addressing : 추가적인 자료구조를 사용하지 않고 해결하는 방법 - 공간 절약
	- Linear Probing : i 인덱스의 셀이 이미 사용중이면 i + 1에 할당 - 빈 공간 나올때까지
	- Double Hashing : 추가적인 해시 함수 사용
		- A[h(k)] 이 이미 사용중이면, A[(i + j * h'(k)) mod N] 사용 (j = 1,2,3,...)
		- h'(k) 로 보통 q - (k mod q) 사용
	
	
#### 탐색 방법들의 시간 복잡도

| |탐색|삽입|삭제|
|-------------|--------------|---------|---------|
|순차 탐색|O(n)|O(1)|O(n)|
|이진 탐색|O(log n)|O(log n + n)|O(log n + n)|
|이진 탐색 트리(균형)|O(log n)|O(log n)|O(log n)|
|이진 탐색 트리(경사)|O(n)|O(n)|O(n)|
|해싱(최선)|O(1)|O(1)|O(1)|
|해싱(최악)|O(n)|O(n)|O(n)|


				


## 9. 그래프 (Graph)
- 정점(Vertex)과 간선(Edge)으로 이루어진 자료구조

#### 그래프와 트리의 차이
|그래프|트리|
|----------------------------|--------------------------------|
|노드들을 연결하는 간선들의 집합|사이클이 없는 연결 그래프|
|사이클 가능|사이클 존재 불가능|
|두 정점 사이 여러 경로 가능|두 정점 사이 반드시 1개 경로|
|간선 수 다양|간선 수 = 정점 수 - 1|

- 트리는 그래프의 한 종류
- incident : 정점 - 간선 간의 인접 관계
- adjacent : 정점 - 정점 간의 인접 관계
	
	
#### 그래프 표현 방법
1. 인접 행렬
	- 노드 i와 j의 인접(adjacent) 여부를 O(1) 시간에 확인 가능
	- 밀집한(dense) 그래프에서 효율적
	- 구현 쉬움
2. 인접 리스트
	- 노드 v에 인접한(incident) 간선 정보를 O(deg(v)) 시간에 확인 가능
	- 드문(sparse) 그래프에서 효율적
	- 구현 살짝 복잡



#### 그래프 순회 방법
1. 깊이 우선 탐색 (Depth First Search, DFS)
	- 갈수 있을 때까지 계속 가다가 막히면 가까운 갈림길로 돌아와서 다시 탐색
	- 재귀를 이용해서 구현
	- 정점 방문 여부를 반드시 기록 -> 안하면 무한 루프
```
DFS(G, v):
	visited[v] = true;
	for all edges from v to w in G.incidentEdges(v)
		if (w is not visited)
			DFS(G, w)
```

2. 너비 우선 탐색 (Breadth First Search)
	- 최단 경로 찾기에 용이
	- 거리가 가까운 정점부터 방문
	- queue를 사용
```
BFS(G, s):
	queue.push(s)
	while queue is not empty
		v = queue.pop()
		for each vertex w adjacent on v
			if (v is not explored)
				queue.push(w)
				label w as discovered
```
